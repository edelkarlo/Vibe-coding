# Network Lab Web Application - Developer Guide

This guide provides instructions for setting up the development environment, running the application locally, and understanding the project structure.

## 1. Prerequisites

*   **Node.js and npm:** For frontend development (React/Vite). (LTS version recommended, e.g., Node 18.x or later).
*   **Python:** For backend development (Flask). (Python 3.9+ recommended).
*   **PostgreSQL:** Database server. Ensure it's installed and running.
*   **Git:** For version control.
*   **(Optional) Docker:** For containerized development or deployment.

## 2. Project Setup

1.  **Clone the Repository:**
    ```bash
    git clone <repository_url>
    cd network-lab-app
    ```

2.  **Backend Setup (Flask):**
    *   Navigate to the backend directory:
        ```bash
        cd backend
        ```
    *   Create and activate a Python virtual environment:
        ```bash
        python3 -m venv venv
        source venv/bin/activate  # On macOS/Linux
        # venv\Scripts\activate    # On Windows
        ```
    *   Install Python dependencies:
        ```bash
        pip install -r requirements.txt
        ```
    *   **Database Configuration:**
        *   Ensure your PostgreSQL server is running.
        *   Create a database (e.g., `network_lab_db`) and a user with privileges for this database.
        *   Create a `.env` file in the `backend/` directory by copying `.env.example` (if provided) or creating it manually.
            Example `.env` content:
            ```env
            FLASK_APP=run.py
            FLASK_DEBUG=1 # Enables debug mode and reloader
            # FLASK_CONFIG=development # Explicitly set config, though default is development

            # Replace with your actual database URL
            DATABASE_URL='postgresql://your_db_user:your_db_password@localhost:5432/network_lab_db'

            # Generate strong random keys for these
            SECRET_KEY='your_flask_secret_key_here'
            JWT_SECRET_KEY='your_jwt_secret_key_here'
            ```
            **Important:** Make sure `.env` is listed in your root `.gitignore` file.
    *   **Database Migrations:**
        *   Once the `DATABASE_URL` in `.env` is correctly configured, apply database migrations:
            ```bash
            flask db upgrade
            ```
        *   To create an initial admin user and default device types (recommended for first setup):
            ```bash
            flask init-db
            ```
            (Default admin: `admin` / `adminpassword` - change this immediately if used beyond local dev).

3.  **Frontend Setup (React/Vite):**
    *   Navigate to the frontend directory:
        ```bash
        cd ../frontend  # If you were in backend/
        # Or from project root: cd frontend
        ```
    *   Install Node.js dependencies:
        ```bash
        npm install
        ```
    *   The frontend is configured to proxy API requests starting with `/api` to `http://localhost:5001` (the default backend port) via `vite.config.ts`. Ensure your backend runs on this port or update the proxy configuration.

## 3. Running the Application Locally

You'll need to run the backend and frontend servers simultaneously in separate terminal sessions.

1.  **Run the Backend (Flask):**
    *   Navigate to `network-lab-app/backend/`.
    *   Activate the virtual environment: `source venv/bin/activate`.
    *   Start the Flask development server:
        ```bash
        flask run --port 5001
        # Or simply `flask run` if port 5001 is default (run.py sets this as fallback)
        ```
        The backend API should now be running, typically at `http://localhost:5001`.

2.  **Run the Frontend (React/Vite):**
    *   Navigate to `network-lab-app/frontend/`.
    *   Start the Vite development server:
        ```bash
        npm run dev
        ```
        The frontend application should now be accessible in your browser, typically at `http://localhost:3000` (Vite's default, or as specified in `vite.config.ts`). Vite will show the exact URL.

## 4. Project Structure Overview

(Refer to the Project Structure section in `README.md` for a directory layout).

*   **`backend/`**: Contains the Flask application.
    *   **`app/`**: The main application package.
        *   `__init__.py`: Application factory (`create_app`), extension initialization.
        *   `models.py`: SQLAlchemy database models.
        *   `routes/`: API blueprints for different parts of the application (auth, admin, lab).
        *   `schemas.py`: (Optional, currently placeholder) For Marshmallow/Pydantic data validation/serialization.
    *   `migrations/`: Database migration scripts generated by Flask-Migrate/Alembic.
    *   `tests/`: Pytest unit tests for the backend.
        *   `conftest.py`: Pytest fixtures.
    *   `venv/`: Python virtual environment (should be gitignored).
    *   `.flaskenv`: Environment variables for the `flask` CLI (e.g., `FLASK_APP`, `FLASK_DEBUG`).
    *   `config.py`: Configuration classes (Development, Testing, Production).
    *   `requirements.txt`: Python dependencies.
    *   `run.py`: Entry point for running the Flask app, defining CLI commands.
*   **`frontend/`**: Contains the React application (Vite + TypeScript).
    *   **`public/`**: Static assets that are copied directly to the build output (e.g., `index.html`, icons).
    *   **`src/`**: Main source code for the React app.
        *   `main.tsx`: Entry point, renders the `App` component.
        *   `App.tsx`: Root component, sets up routing and global providers (e.g., `AuthProvider`).
        *   `components/`: Reusable UI components (e.g., Navbar, admin forms, lab elements).
        *   `contexts/`: React Context API providers (e.g., `AuthContext`).
        *   `pages/`: Top-level components for each route/page (e.g., `HomePage`, `LoginPage`, `LabEditorPage`).
        *   `services/`: Modules for making API calls to the backend (e.g., `authService.ts`, `adminService.ts`).
        *   `assets/`: Other static assets like CSS, images imported by components.
    *   `vite.config.ts`: Vite configuration file (e.g., for development server proxy).
    *   `package.json`: Lists frontend dependencies and npm scripts.

## 5. Backend Development Notes

*   **Models:** Defined in `backend/app/models.py` using Flask-SQLAlchemy.
*   **Routes/Blueprints:** API endpoints are organized into Blueprints in `backend/app/routes/`.
*   **Database Migrations:**
    *   After changing SQLAlchemy models, generate a new migration:
        ```bash
        flask db migrate -m "Description of changes"
        ```
    *   Apply the migration:
        ```bash
        flask db upgrade
        ```
*   **Testing (Backend):**
    *   Tests are in `backend/tests/`.
    *   Run tests using Pytest from the `backend/` directory (ensure venv is active):
        ```bash
        pytest
        ```
    *   The test environment uses the `TestingConfig` from `config.py`. `conftest.py` sets up a test app and client. For database tests, it's configured to use an in-memory SQLite database by default or can be pointed to a test PostgreSQL instance.

## 6. Frontend Development Notes

*   **Components:** Follow a component-based architecture.
*   **State Management:** Global state (like authentication) is handled via React Context. Component-level state uses `useState`, `useReducer`.
*   **API Interaction:** Axios is used in service modules (`src/services/`) for backend communication.
*   **Styling:** Basic inline styles are used for now. Consider adopting a CSS methodology (e.g., CSS Modules, Tailwind CSS, a UI component library like MUI or Chakra UI) for larger-scale styling.
*   **Testing (Frontend):**
    *   Vite sets up Vitest (or Jest) and React Testing Library.
    *   Test files are typically co-located with components (e.g., `MyComponent.test.tsx`) or in a `__tests__` subdirectory.
    *   Run tests:
        ```bash
        npm test
        ```

## 7. Adding Device Icons

*   Place new SVG icons in `frontend/public/icons/`.
*   Update the `default_icon_path` for `DeviceTypes` or `DeviceConfigs` in the admin panel to point to the new icon (e.g., `icons/new_device.svg`). The path is relative to the `public` directory.

## 8. Key Environment Variables

(Summarize critical environment variables needed for both backend and frontend, especially for production).
*   **Backend:** `FLASK_CONFIG`, `SECRET_KEY`, `JWT_SECRET_KEY`, `DATABASE_URL`.
*   **Frontend (Build Time):** `VITE_API_BASE_URL` (if not using proxy for all environments or if base URL needs to be dynamic).

---
This guide should help you get started with developing the Network Lab application.

## 9. Maintenance and Future Enhancements

### 9.1. Bug Fixes
*   **Issue Tracking:** Use a dedicated issue tracker (e.g., GitHub Issues, Jira) to log, prioritize, and track bugs.
*   **Branching Strategy:** Use a clear branching strategy (e.g., Gitflow with feature branches, hotfix branches) for developing fixes.
*   **Testing:** Ensure bug fixes include corresponding unit or integration tests to prevent regressions.
*   **Code Review:** All fixes should be peer-reviewed before merging into the main development branch.
*   **Release Cycle:** Define a release cycle or process for deploying fixes (e.g., patch releases).

### 9.2. Dependency Updates
*   **Backend (Python/Pip):**
    *   Regularly review `requirements.txt`.
    *   Use `pip list --outdated` to check for outdated packages.
    *   Update packages cautiously, testing thoroughly after each significant update (e.g., Flask, SQLAlchemy major versions).
    *   Use tools like `pip-tools` (to compile `requirements.in` to `requirements.txt`) for better dependency management and pinning.
    *   Monitor for security vulnerabilities in dependencies (e.g., using `safety check -r requirements.txt` or GitHub Dependabot).
*   **Frontend (Node.js/npm):**
    *   Regularly review `package.json`.
    *   Use `npm outdated` to check for outdated packages.
    *   Update packages using `npm update` or by manually changing versions in `package.json` and running `npm install`. Test thoroughly.
    *   Pay attention to major version updates of core libraries like React, Vite, React Router, React Flow.
    *   Use `npm audit` to check for security vulnerabilities in frontend dependencies. GitHub Dependabot is also excellent here.
*   **Node.js & Python Versions:** Periodically update the Node.js and Python runtime versions themselves as new LTS or stable versions are released, after testing compatibility.

### 9.3. Code Refactoring and Technical Debt
*   Schedule time for refactoring parts of the codebase that become complex or hard to maintain.
*   Address technical debt proactively to improve code quality and developer productivity in the long run.
*   Keep code documentation (comments, docstrings) up-to-date.

### 9.4. Database Maintenance (for PostgreSQL)
*   **Backups:** Implement regular automated backups of the PostgreSQL database. Test restoration procedures.
*   **Monitoring:** Monitor database performance, disk space, and logs.
*   **Vacuuming/Analyzing:** Ensure PostgreSQL's autovacuum is running effectively, or schedule manual `VACUUM ANALYZE` as needed for performance.
*   **Upgrades:** Plan for PostgreSQL major version upgrades, which require careful planning and testing.

### 9.5. Future Enhancements
(This section would list potential new features or improvements based on user feedback or project roadmap). Some ideas based on the current project:
*   **More Sophisticated Device Nodes:** Allow custom properties per device instance on the canvas, different icon states (on/off).
*   **Advanced Connection Types:** Different cable types, link status visualization.
*   **SSH Credential Management (Optional/Secure):** Explore secure ways to pre-configure or prompt for SSH credentials if desired, beyond manual input in the SSH client.
*   **Multi-user Collaboration on Labs:** (Significant feature) Allow multiple users to view or edit the same lab topology.
*   **Lab Snapshots/Versioning:** Allow saving different versions of a lab topology.
*   **Integration with Real/Virtual Device Management:** (Advanced) APIs to interact with virtualization platforms (like GNS3 server, EVE-NG) to actually spin up/down the devices represented on the canvas.
*   **User Roles & Permissions:** More granular permissions beyond just admin/non-admin.
*   **UI/UX Improvements:** Theming, better error handling, more interactive elements.
*   **Scalability Improvements:** For backend and database if user load increases significantly.
*   **Comprehensive Test Coverage:** Increase unit, integration, and E2E test coverage.
*   **Accessibility (a11y):** Ensure the application is usable by people with disabilities.
```
